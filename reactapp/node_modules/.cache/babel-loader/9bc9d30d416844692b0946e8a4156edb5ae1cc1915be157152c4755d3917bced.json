{"ast":null,"code":"import _objectSpread from\"/Users/armeshpereira/Documents/LastAttempt/reactapp/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{Preferences}from'@capacitor/preferences';import{Filesystem,Directory,Encoding}from'@capacitor/filesystem';import{Capacitor}from'@capacitor/core';export class BleAudioDataManager{constructor(){this.DEVICE_SETTINGS_PREFIX='ble_device_';this.KNOWN_DEVICES_KEY='ble_known_devices';this.RECORDING_SESSIONS_KEY='recording_sessions';}// Device Management with Preferences\nasync saveDeviceSettings(deviceId,settings){await Preferences.set({key:\"\".concat(this.DEVICE_SETTINGS_PREFIX).concat(deviceId),value:JSON.stringify(_objectSpread(_objectSpread({},settings),{},{lastUpdated:new Date().toISOString()}))});}async getDeviceSettings(deviceId){const{value}=await Preferences.get({key:\"\".concat(this.DEVICE_SETTINGS_PREFIX).concat(deviceId)});return value?JSON.parse(value):null;}async addKnownDevice(deviceId,deviceInfo){// Save to known devices list\nconst{value}=await Preferences.get({key:this.KNOWN_DEVICES_KEY});const knownDevices=value?JSON.parse(value):[];const existingIndex=knownDevices.findIndex(d=>d.id===deviceId);const deviceData=_objectSpread(_objectSpread({id:deviceId},deviceInfo),{},{lastSeen:new Date().toISOString()});if(existingIndex>=0){knownDevices[existingIndex]=deviceData;}else{knownDevices.push(deviceData);}await Preferences.set({key:this.KNOWN_DEVICES_KEY,value:JSON.stringify(knownDevices)});}async getKnownDevices(){const{value}=await Preferences.get({key:this.KNOWN_DEVICES_KEY});return value?JSON.parse(value):[];}// Audio Recording Session Management\nasync startRecordingSession(deviceId){let sessionInfo=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const sessionId=\"session_\".concat(deviceId,\"_\").concat(Date.now());const session=_objectSpread({id:sessionId,deviceId,startTime:new Date().toISOString(),status:'recording'},sessionInfo);// Save session info to preferences\nconst{value}=await Preferences.get({key:this.RECORDING_SESSIONS_KEY});const sessions=value?JSON.parse(value):[];sessions.push(session);await Preferences.set({key:this.RECORDING_SESSIONS_KEY,value:JSON.stringify(sessions)});// Create log file for real-time data\nconst logFile=\"audio_stream_\".concat(sessionId,\".log\");const header=\"# Audio Stream Log for \".concat(deviceId,\"\\n# Session: \").concat(sessionId,\"\\n# Started: \").concat(session.startTime,\"\\n\\n\");await Filesystem.writeFile({path:\"audio_logs/\".concat(logFile),data:header,directory:Directory.Documents,encoding:Encoding.UTF8,recursive:true});return{sessionId,logFile};}async logAudioData(sessionId,audioData){let metadata=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};const logFile=\"audio_stream_\".concat(sessionId,\".log\");const timestamp=new Date().toISOString();// Convert Int16Array to readable format\nconst samples=Array.from(audioData);const audioInfo=_objectSpread({timestamp,sessionId,sampleCount:audioData.length,samples:samples.slice(0,10),// First 10 samples for debugging\nrange:{min:Math.min(...samples),max:Math.max(...samples)}},metadata);const logEntry=\"\".concat(timestamp,\" | \").concat(JSON.stringify(audioInfo),\"\\n\");try{await Filesystem.appendFile({path:\"audio_logs/\".concat(logFile),data:logEntry,directory:Directory.Documents,encoding:Encoding.UTF8});}catch(error){console.error('Error logging audio data:',error);}}async saveAudioRecording(sessionId,audioData){let metadata=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};const timestamp=new Date().toISOString().replace(/[:.]/g,'-');const fileName=\"recording_\".concat(sessionId,\"_\").concat(timestamp,\".wav\");// Create WAV file from audio data\nconst wavBlob=this.createWavBlob(audioData);// Convert blob to base64 for storage\nconst arrayBuffer=await wavBlob.arrayBuffer();const base64Data=btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));const recording=_objectSpread({sessionId,fileName,timestamp:new Date().toISOString(),sampleCount:audioData.length,duration:audioData.length/16000,// Assuming 16kHz sample rate\nfileSize:wavBlob.size},metadata);// Save audio file\nawait Filesystem.writeFile({path:\"recordings/\".concat(fileName),data:base64Data,directory:Directory.Documents,recursive:true});// Save recording metadata\nconst metadataFile=\"recording_\".concat(sessionId,\"_\").concat(timestamp,\".json\");await Filesystem.writeFile({path:\"recordings/\".concat(metadataFile),data:JSON.stringify(recording,null,2),directory:Directory.Documents,encoding:Encoding.UTF8,recursive:true});// Update session status\nawait this.updateSessionStatus(sessionId,'completed',recording);return{fileName,metadataFile,recording};}async updateSessionStatus(sessionId,status){let data=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};const{value}=await Preferences.get({key:this.RECORDING_SESSIONS_KEY});const sessions=value?JSON.parse(value):[];const sessionIndex=sessions.findIndex(s=>s.id===sessionId);if(sessionIndex>=0){sessions[sessionIndex]=_objectSpread(_objectSpread({},sessions[sessionIndex]),{},{status,endTime:new Date().toISOString()},data);await Preferences.set({key:this.RECORDING_SESSIONS_KEY,value:JSON.stringify(sessions)});}}async getRecordingSessions(){let deviceId=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;const{value}=await Preferences.get({key:this.RECORDING_SESSIONS_KEY});const sessions=value?JSON.parse(value):[];return deviceId?sessions.filter(s=>s.deviceId===deviceId):sessions;}async listRecordings(){try{const result=await Filesystem.readdir({path:'recordings',directory:Directory.Documents});return result.files.filter(file=>file.name.endsWith('.wav')||file.name.endsWith('.json'));}catch(error){console.error('Error listing recordings:',error);return[];}}async getRecording(metadataFile){try{const result=await Filesystem.readFile({path:\"recordings/\".concat(metadataFile),directory:Directory.Documents,encoding:Encoding.UTF8});return JSON.parse(result.data);}catch(error){console.error('Error reading recording metadata:',error);return null;}}async playRecording(fileName){try{const result=await Filesystem.readFile({path:\"recordings/\".concat(fileName),directory:Directory.Documents});// Convert base64 back to blob\nconst binaryString=atob(result.data);const bytes=new Uint8Array(binaryString.length);for(let i=0;i<binaryString.length;i++){bytes[i]=binaryString.charCodeAt(i);}return new Blob([bytes],{type:'audio/wav'});}catch(error){console.error('Error reading recording file:',error);return null;}}async exportRecording(fileName){if(Capacitor.isNativePlatform()){// On iOS/Android, file is already in Documents directory\n// User can access it through Files app\nreturn fileName;}else{// On web, trigger download\nconst blob=await this.playRecording(fileName);if(blob){const url=URL.createObjectURL(blob);const a=document.createElement('a');a.href=url;a.download=fileName;document.body.appendChild(a);a.click();document.body.removeChild(a);URL.revokeObjectURL(url);}return fileName;}}async cleanupOldData(){let daysToKeep=arguments.length>0&&arguments[0]!==undefined?arguments[0]:7;const cutoffDate=new Date();cutoffDate.setDate(cutoffDate.getDate()-daysToKeep);// Clean up old sessions\nconst sessions=await this.getRecordingSessions();const recentSessions=sessions.filter(s=>new Date(s.startTime)>cutoffDate);await Preferences.set({key:this.RECORDING_SESSIONS_KEY,value:JSON.stringify(recentSessions)});// Clean up old files\ntry{const recordings=await this.listRecordings();for(const file of recordings){const stat=await Filesystem.stat({path:\"recordings/\".concat(file.name),directory:Directory.Documents});if(stat.mtime<cutoffDate.getTime()){await Filesystem.deleteFile({path:\"recordings/\".concat(file.name),directory:Directory.Documents});console.log(\"Deleted old recording: \".concat(file.name));}}}catch(error){console.error('Error cleaning up old data:',error);}}// Helper method to create WAV blob\ncreateWavBlob(audioData){const SAMPLE_RATE=16000;const CHANNELS=1;const SAMPLE_WIDTH=2;const buffer=new ArrayBuffer(44+audioData.length*2);const view=new DataView(buffer);// WAV header\nconst writeString=(offset,string)=>{for(let i=0;i<string.length;i++){view.setUint8(offset+i,string.charCodeAt(i));}};writeString(0,'RIFF');view.setUint32(4,36+audioData.length*2,true);writeString(8,'WAVE');writeString(12,'fmt ');view.setUint32(16,16,true);view.setUint16(20,1,true);view.setUint16(22,CHANNELS,true);view.setUint32(24,SAMPLE_RATE,true);view.setUint32(28,SAMPLE_RATE*CHANNELS*SAMPLE_WIDTH,true);view.setUint16(32,CHANNELS*SAMPLE_WIDTH,true);view.setUint16(34,16,true);writeString(36,'data');view.setUint32(40,audioData.length*2,true);// Write audio data\nlet offset=44;for(let i=0;i<audioData.length;i++){view.setInt16(offset,audioData[i],true);offset+=2;}return new Blob([buffer],{type:'audio/wav'});}async clearAllData(){// Clear preferences\nawait Preferences.clear();// Clear filesystem data\ntry{await Filesystem.rmdir({path:'audio_logs',directory:Directory.Documents,recursive:true});await Filesystem.rmdir({path:'recordings',directory:Directory.Documents,recursive:true});}catch(error){console.log('Some directories may not exist:',error);}}}// Export singleton instance\nexport const bleAudioDataManager=new BleAudioDataManager();","map":{"version":3,"names":["Preferences","Filesystem","Directory","Encoding","Capacitor","BleAudioDataManager","constructor","DEVICE_SETTINGS_PREFIX","KNOWN_DEVICES_KEY","RECORDING_SESSIONS_KEY","saveDeviceSettings","deviceId","settings","set","key","concat","value","JSON","stringify","_objectSpread","lastUpdated","Date","toISOString","getDeviceSettings","get","parse","addKnownDevice","deviceInfo","knownDevices","existingIndex","findIndex","d","id","deviceData","lastSeen","push","getKnownDevices","startRecordingSession","sessionInfo","arguments","length","undefined","sessionId","now","session","startTime","status","sessions","logFile","header","writeFile","path","data","directory","Documents","encoding","UTF8","recursive","logAudioData","audioData","metadata","timestamp","samples","Array","from","audioInfo","sampleCount","slice","range","min","Math","max","logEntry","appendFile","error","console","saveAudioRecording","replace","fileName","wavBlob","createWavBlob","arrayBuffer","base64Data","btoa","String","fromCharCode","Uint8Array","recording","duration","fileSize","size","metadataFile","updateSessionStatus","sessionIndex","s","endTime","getRecordingSessions","filter","listRecordings","result","readdir","files","file","name","endsWith","getRecording","readFile","playRecording","binaryString","atob","bytes","i","charCodeAt","Blob","type","exportRecording","isNativePlatform","blob","url","URL","createObjectURL","a","document","createElement","href","download","body","appendChild","click","removeChild","revokeObjectURL","cleanupOldData","daysToKeep","cutoffDate","setDate","getDate","recentSessions","recordings","stat","mtime","getTime","deleteFile","log","SAMPLE_RATE","CHANNELS","SAMPLE_WIDTH","buffer","ArrayBuffer","view","DataView","writeString","offset","string","setUint8","setUint32","setUint16","setInt16","clearAllData","clear","rmdir","bleAudioDataManager"],"sources":["/Users/armeshpereira/Documents/LastAttempt/reactapp/src/utils/BleAudioDataManager.js"],"sourcesContent":["import { Preferences } from '@capacitor/preferences';\nimport { Filesystem, Directory, Encoding } from '@capacitor/filesystem';\nimport { Capacitor } from '@capacitor/core';\n\nexport class BleAudioDataManager {\n  constructor() {\n    this.DEVICE_SETTINGS_PREFIX = 'ble_device_';\n    this.KNOWN_DEVICES_KEY = 'ble_known_devices';\n    this.RECORDING_SESSIONS_KEY = 'recording_sessions';\n  }\n  \n  // Device Management with Preferences\n  async saveDeviceSettings(deviceId, settings) {\n    await Preferences.set({\n      key: `${this.DEVICE_SETTINGS_PREFIX}${deviceId}`,\n      value: JSON.stringify({\n        ...settings,\n        lastUpdated: new Date().toISOString()\n      })\n    });\n  }\n  \n  async getDeviceSettings(deviceId) {\n    const { value } = await Preferences.get({\n      key: `${this.DEVICE_SETTINGS_PREFIX}${deviceId}`\n    });\n    return value ? JSON.parse(value) : null;\n  }\n  \n  async addKnownDevice(deviceId, deviceInfo) {\n    // Save to known devices list\n    const { value } = await Preferences.get({ key: this.KNOWN_DEVICES_KEY });\n    const knownDevices = value ? JSON.parse(value) : [];\n    \n    const existingIndex = knownDevices.findIndex((d) => d.id === deviceId);\n    const deviceData = {\n      id: deviceId,\n      ...deviceInfo,\n      lastSeen: new Date().toISOString()\n    };\n    \n    if (existingIndex >= 0) {\n      knownDevices[existingIndex] = deviceData;\n    } else {\n      knownDevices.push(deviceData);\n    }\n    \n    await Preferences.set({\n      key: this.KNOWN_DEVICES_KEY,\n      value: JSON.stringify(knownDevices)\n    });\n  }\n  \n  async getKnownDevices() {\n    const { value } = await Preferences.get({ key: this.KNOWN_DEVICES_KEY });\n    return value ? JSON.parse(value) : [];\n  }\n  \n  // Audio Recording Session Management\n  async startRecordingSession(deviceId, sessionInfo = {}) {\n    const sessionId = `session_${deviceId}_${Date.now()}`;\n    const session = {\n      id: sessionId,\n      deviceId,\n      startTime: new Date().toISOString(),\n      status: 'recording',\n      ...sessionInfo\n    };\n    \n    // Save session info to preferences\n    const { value } = await Preferences.get({ key: this.RECORDING_SESSIONS_KEY });\n    const sessions = value ? JSON.parse(value) : [];\n    sessions.push(session);\n    await Preferences.set({\n      key: this.RECORDING_SESSIONS_KEY,\n      value: JSON.stringify(sessions)\n    });\n    \n    // Create log file for real-time data\n    const logFile = `audio_stream_${sessionId}.log`;\n    const header = `# Audio Stream Log for ${deviceId}\\n# Session: ${sessionId}\\n# Started: ${session.startTime}\\n\\n`;\n    \n    await Filesystem.writeFile({\n      path: `audio_logs/${logFile}`,\n      data: header,\n      directory: Directory.Documents,\n      encoding: Encoding.UTF8,\n      recursive: true\n    });\n    \n    return { sessionId, logFile };\n  }\n  \n  async logAudioData(sessionId, audioData, metadata = {}) {\n    const logFile = `audio_stream_${sessionId}.log`;\n    const timestamp = new Date().toISOString();\n    \n    // Convert Int16Array to readable format\n    const samples = Array.from(audioData);\n    const audioInfo = {\n      timestamp,\n      sessionId,\n      sampleCount: audioData.length,\n      samples: samples.slice(0, 10), // First 10 samples for debugging\n      range: {\n        min: Math.min(...samples),\n        max: Math.max(...samples)\n      },\n      ...metadata\n    };\n    \n    const logEntry = `${timestamp} | ${JSON.stringify(audioInfo)}\\n`;\n    \n    try {\n      await Filesystem.appendFile({\n        path: `audio_logs/${logFile}`,\n        data: logEntry,\n        directory: Directory.Documents,\n        encoding: Encoding.UTF8\n      });\n    } catch (error) {\n      console.error('Error logging audio data:', error);\n    }\n  }\n  \n  async saveAudioRecording(sessionId, audioData, metadata = {}) {\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    const fileName = `recording_${sessionId}_${timestamp}.wav`;\n    \n    // Create WAV file from audio data\n    const wavBlob = this.createWavBlob(audioData);\n    \n    // Convert blob to base64 for storage\n    const arrayBuffer = await wavBlob.arrayBuffer();\n    const base64Data = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));\n    \n    const recording = {\n      sessionId,\n      fileName,\n      timestamp: new Date().toISOString(),\n      sampleCount: audioData.length,\n      duration: audioData.length / 16000, // Assuming 16kHz sample rate\n      fileSize: wavBlob.size,\n      ...metadata\n    };\n    \n    // Save audio file\n    await Filesystem.writeFile({\n      path: `recordings/${fileName}`,\n      data: base64Data,\n      directory: Directory.Documents,\n      recursive: true\n    });\n    \n    // Save recording metadata\n    const metadataFile = `recording_${sessionId}_${timestamp}.json`;\n    await Filesystem.writeFile({\n      path: `recordings/${metadataFile}`,\n      data: JSON.stringify(recording, null, 2),\n      directory: Directory.Documents,\n      encoding: Encoding.UTF8,\n      recursive: true\n    });\n    \n    // Update session status\n    await this.updateSessionStatus(sessionId, 'completed', recording);\n    \n    return { fileName, metadataFile, recording };\n  }\n  \n  async updateSessionStatus(sessionId, status, data = {}) {\n    const { value } = await Preferences.get({ key: this.RECORDING_SESSIONS_KEY });\n    const sessions = value ? JSON.parse(value) : [];\n    \n    const sessionIndex = sessions.findIndex(s => s.id === sessionId);\n    if (sessionIndex >= 0) {\n      sessions[sessionIndex] = {\n        ...sessions[sessionIndex],\n        status,\n        endTime: new Date().toISOString(),\n        ...data\n      };\n      \n      await Preferences.set({\n        key: this.RECORDING_SESSIONS_KEY,\n        value: JSON.stringify(sessions)\n      });\n    }\n  }\n  \n  async getRecordingSessions(deviceId = null) {\n    const { value } = await Preferences.get({ key: this.RECORDING_SESSIONS_KEY });\n    const sessions = value ? JSON.parse(value) : [];\n    \n    return deviceId ? sessions.filter(s => s.deviceId === deviceId) : sessions;\n  }\n  \n  async listRecordings() {\n    try {\n      const result = await Filesystem.readdir({\n        path: 'recordings',\n        directory: Directory.Documents\n      });\n      \n      return result.files.filter(file => \n        file.name.endsWith('.wav') || file.name.endsWith('.json')\n      );\n    } catch (error) {\n      console.error('Error listing recordings:', error);\n      return [];\n    }\n  }\n  \n  async getRecording(metadataFile) {\n    try {\n      const result = await Filesystem.readFile({\n        path: `recordings/${metadataFile}`,\n        directory: Directory.Documents,\n        encoding: Encoding.UTF8\n      });\n      \n      return JSON.parse(result.data);\n    } catch (error) {\n      console.error('Error reading recording metadata:', error);\n      return null;\n    }\n  }\n  \n  async playRecording(fileName) {\n    try {\n      const result = await Filesystem.readFile({\n        path: `recordings/${fileName}`,\n        directory: Directory.Documents\n      });\n      \n      // Convert base64 back to blob\n      const binaryString = atob(result.data);\n      const bytes = new Uint8Array(binaryString.length);\n      for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n      }\n      \n      return new Blob([bytes], { type: 'audio/wav' });\n    } catch (error) {\n      console.error('Error reading recording file:', error);\n      return null;\n    }\n  }\n  \n  async exportRecording(fileName) {\n    if (Capacitor.isNativePlatform()) {\n      // On iOS/Android, file is already in Documents directory\n      // User can access it through Files app\n      return fileName;\n    } else {\n      // On web, trigger download\n      const blob = await this.playRecording(fileName);\n      if (blob) {\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = fileName;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n      }\n      return fileName;\n    }\n  }\n  \n  async cleanupOldData(daysToKeep = 7) {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - daysToKeep);\n    \n    // Clean up old sessions\n    const sessions = await this.getRecordingSessions();\n    const recentSessions = sessions.filter(s => \n      new Date(s.startTime) > cutoffDate\n    );\n    \n    await Preferences.set({\n      key: this.RECORDING_SESSIONS_KEY,\n      value: JSON.stringify(recentSessions)\n    });\n    \n    // Clean up old files\n    try {\n      const recordings = await this.listRecordings();\n      for (const file of recordings) {\n        const stat = await Filesystem.stat({\n          path: `recordings/${file.name}`,\n          directory: Directory.Documents\n        });\n        \n        if (stat.mtime < cutoffDate.getTime()) {\n          await Filesystem.deleteFile({\n            path: `recordings/${file.name}`,\n            directory: Directory.Documents\n          });\n          console.log(`Deleted old recording: ${file.name}`);\n        }\n      }\n    } catch (error) {\n      console.error('Error cleaning up old data:', error);\n    }\n  }\n  \n  // Helper method to create WAV blob\n  createWavBlob(audioData) {\n    const SAMPLE_RATE = 16000;\n    const CHANNELS = 1;\n    const SAMPLE_WIDTH = 2;\n    \n    const buffer = new ArrayBuffer(44 + audioData.length * 2);\n    const view = new DataView(buffer);\n    \n    // WAV header\n    const writeString = (offset, string) => {\n      for (let i = 0; i < string.length; i++) {\n        view.setUint8(offset + i, string.charCodeAt(i));\n      }\n    };\n    \n    writeString(0, 'RIFF');\n    view.setUint32(4, 36 + audioData.length * 2, true);\n    writeString(8, 'WAVE');\n    writeString(12, 'fmt ');\n    view.setUint32(16, 16, true);\n    view.setUint16(20, 1, true);\n    view.setUint16(22, CHANNELS, true);\n    view.setUint32(24, SAMPLE_RATE, true);\n    view.setUint32(28, SAMPLE_RATE * CHANNELS * SAMPLE_WIDTH, true);\n    view.setUint16(32, CHANNELS * SAMPLE_WIDTH, true);\n    view.setUint16(34, 16, true);\n    writeString(36, 'data');\n    view.setUint32(40, audioData.length * 2, true);\n    \n    // Write audio data\n    let offset = 44;\n    for (let i = 0; i < audioData.length; i++) {\n      view.setInt16(offset, audioData[i], true);\n      offset += 2;\n    }\n    \n    return new Blob([buffer], { type: 'audio/wav' });\n  }\n  \n  async clearAllData() {\n    // Clear preferences\n    await Preferences.clear();\n    \n    // Clear filesystem data\n    try {\n      await Filesystem.rmdir({\n        path: 'audio_logs',\n        directory: Directory.Documents,\n        recursive: true\n      });\n      await Filesystem.rmdir({\n        path: 'recordings',\n        directory: Directory.Documents,\n        recursive: true\n      });\n    } catch (error) {\n      console.log('Some directories may not exist:', error);\n    }\n  }\n}\n\n// Export singleton instance\nexport const bleAudioDataManager = new BleAudioDataManager();\n"],"mappings":"wIAAA,OAASA,WAAW,KAAQ,wBAAwB,CACpD,OAASC,UAAU,CAAEC,SAAS,CAAEC,QAAQ,KAAQ,uBAAuB,CACvE,OAASC,SAAS,KAAQ,iBAAiB,CAE3C,MAAO,MAAM,CAAAC,mBAAoB,CAC/BC,WAAWA,CAAA,CAAG,CACZ,IAAI,CAACC,sBAAsB,CAAG,aAAa,CAC3C,IAAI,CAACC,iBAAiB,CAAG,mBAAmB,CAC5C,IAAI,CAACC,sBAAsB,CAAG,oBAAoB,CACpD,CAEA;AACA,KAAM,CAAAC,kBAAkBA,CAACC,QAAQ,CAAEC,QAAQ,CAAE,CAC3C,KAAM,CAAAZ,WAAW,CAACa,GAAG,CAAC,CACpBC,GAAG,IAAAC,MAAA,CAAK,IAAI,CAACR,sBAAsB,EAAAQ,MAAA,CAAGJ,QAAQ,CAAE,CAChDK,KAAK,CAAEC,IAAI,CAACC,SAAS,CAAAC,aAAA,CAAAA,aAAA,IAChBP,QAAQ,MACXQ,WAAW,CAAE,GAAI,CAAAC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,EACtC,CACH,CAAC,CAAC,CACJ,CAEA,KAAM,CAAAC,iBAAiBA,CAACZ,QAAQ,CAAE,CAChC,KAAM,CAAEK,KAAM,CAAC,CAAG,KAAM,CAAAhB,WAAW,CAACwB,GAAG,CAAC,CACtCV,GAAG,IAAAC,MAAA,CAAK,IAAI,CAACR,sBAAsB,EAAAQ,MAAA,CAAGJ,QAAQ,CAChD,CAAC,CAAC,CACF,MAAO,CAAAK,KAAK,CAAGC,IAAI,CAACQ,KAAK,CAACT,KAAK,CAAC,CAAG,IAAI,CACzC,CAEA,KAAM,CAAAU,cAAcA,CAACf,QAAQ,CAAEgB,UAAU,CAAE,CACzC;AACA,KAAM,CAAEX,KAAM,CAAC,CAAG,KAAM,CAAAhB,WAAW,CAACwB,GAAG,CAAC,CAAEV,GAAG,CAAE,IAAI,CAACN,iBAAkB,CAAC,CAAC,CACxE,KAAM,CAAAoB,YAAY,CAAGZ,KAAK,CAAGC,IAAI,CAACQ,KAAK,CAACT,KAAK,CAAC,CAAG,EAAE,CAEnD,KAAM,CAAAa,aAAa,CAAGD,YAAY,CAACE,SAAS,CAAEC,CAAC,EAAKA,CAAC,CAACC,EAAE,GAAKrB,QAAQ,CAAC,CACtE,KAAM,CAAAsB,UAAU,CAAAd,aAAA,CAAAA,aAAA,EACda,EAAE,CAAErB,QAAQ,EACTgB,UAAU,MACbO,QAAQ,CAAE,GAAI,CAAAb,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,EACnC,CAED,GAAIO,aAAa,EAAI,CAAC,CAAE,CACtBD,YAAY,CAACC,aAAa,CAAC,CAAGI,UAAU,CAC1C,CAAC,IAAM,CACLL,YAAY,CAACO,IAAI,CAACF,UAAU,CAAC,CAC/B,CAEA,KAAM,CAAAjC,WAAW,CAACa,GAAG,CAAC,CACpBC,GAAG,CAAE,IAAI,CAACN,iBAAiB,CAC3BQ,KAAK,CAAEC,IAAI,CAACC,SAAS,CAACU,YAAY,CACpC,CAAC,CAAC,CACJ,CAEA,KAAM,CAAAQ,eAAeA,CAAA,CAAG,CACtB,KAAM,CAAEpB,KAAM,CAAC,CAAG,KAAM,CAAAhB,WAAW,CAACwB,GAAG,CAAC,CAAEV,GAAG,CAAE,IAAI,CAACN,iBAAkB,CAAC,CAAC,CACxE,MAAO,CAAAQ,KAAK,CAAGC,IAAI,CAACQ,KAAK,CAACT,KAAK,CAAC,CAAG,EAAE,CACvC,CAEA;AACA,KAAM,CAAAqB,qBAAqBA,CAAC1B,QAAQ,CAAoB,IAAlB,CAAA2B,WAAW,CAAAC,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAG,CAAC,CAAC,CACpD,KAAM,CAAAG,SAAS,YAAA3B,MAAA,CAAcJ,QAAQ,MAAAI,MAAA,CAAIM,IAAI,CAACsB,GAAG,CAAC,CAAC,CAAE,CACrD,KAAM,CAAAC,OAAO,CAAAzB,aAAA,EACXa,EAAE,CAAEU,SAAS,CACb/B,QAAQ,CACRkC,SAAS,CAAE,GAAI,CAAAxB,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,CACnCwB,MAAM,CAAE,WAAW,EAChBR,WAAW,CACf,CAED;AACA,KAAM,CAAEtB,KAAM,CAAC,CAAG,KAAM,CAAAhB,WAAW,CAACwB,GAAG,CAAC,CAAEV,GAAG,CAAE,IAAI,CAACL,sBAAuB,CAAC,CAAC,CAC7E,KAAM,CAAAsC,QAAQ,CAAG/B,KAAK,CAAGC,IAAI,CAACQ,KAAK,CAACT,KAAK,CAAC,CAAG,EAAE,CAC/C+B,QAAQ,CAACZ,IAAI,CAACS,OAAO,CAAC,CACtB,KAAM,CAAA5C,WAAW,CAACa,GAAG,CAAC,CACpBC,GAAG,CAAE,IAAI,CAACL,sBAAsB,CAChCO,KAAK,CAAEC,IAAI,CAACC,SAAS,CAAC6B,QAAQ,CAChC,CAAC,CAAC,CAEF;AACA,KAAM,CAAAC,OAAO,iBAAAjC,MAAA,CAAmB2B,SAAS,QAAM,CAC/C,KAAM,CAAAO,MAAM,2BAAAlC,MAAA,CAA6BJ,QAAQ,kBAAAI,MAAA,CAAgB2B,SAAS,kBAAA3B,MAAA,CAAgB6B,OAAO,CAACC,SAAS,QAAM,CAEjH,KAAM,CAAA5C,UAAU,CAACiD,SAAS,CAAC,CACzBC,IAAI,eAAApC,MAAA,CAAgBiC,OAAO,CAAE,CAC7BI,IAAI,CAAEH,MAAM,CACZI,SAAS,CAAEnD,SAAS,CAACoD,SAAS,CAC9BC,QAAQ,CAAEpD,QAAQ,CAACqD,IAAI,CACvBC,SAAS,CAAE,IACb,CAAC,CAAC,CAEF,MAAO,CAAEf,SAAS,CAAEM,OAAQ,CAAC,CAC/B,CAEA,KAAM,CAAAU,YAAYA,CAAChB,SAAS,CAAEiB,SAAS,CAAiB,IAAf,CAAAC,QAAQ,CAAArB,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAG,CAAC,CAAC,CACpD,KAAM,CAAAS,OAAO,iBAAAjC,MAAA,CAAmB2B,SAAS,QAAM,CAC/C,KAAM,CAAAmB,SAAS,CAAG,GAAI,CAAAxC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,CAE1C;AACA,KAAM,CAAAwC,OAAO,CAAGC,KAAK,CAACC,IAAI,CAACL,SAAS,CAAC,CACrC,KAAM,CAAAM,SAAS,CAAA9C,aAAA,EACb0C,SAAS,CACTnB,SAAS,CACTwB,WAAW,CAAEP,SAAS,CAACnB,MAAM,CAC7BsB,OAAO,CAAEA,OAAO,CAACK,KAAK,CAAC,CAAC,CAAE,EAAE,CAAC,CAAE;AAC/BC,KAAK,CAAE,CACLC,GAAG,CAAEC,IAAI,CAACD,GAAG,CAAC,GAAGP,OAAO,CAAC,CACzBS,GAAG,CAAED,IAAI,CAACC,GAAG,CAAC,GAAGT,OAAO,CAC1B,CAAC,EACEF,QAAQ,CACZ,CAED,KAAM,CAAAY,QAAQ,IAAAzD,MAAA,CAAM8C,SAAS,QAAA9C,MAAA,CAAME,IAAI,CAACC,SAAS,CAAC+C,SAAS,CAAC,MAAI,CAEhE,GAAI,CACF,KAAM,CAAAhE,UAAU,CAACwE,UAAU,CAAC,CAC1BtB,IAAI,eAAApC,MAAA,CAAgBiC,OAAO,CAAE,CAC7BI,IAAI,CAAEoB,QAAQ,CACdnB,SAAS,CAAEnD,SAAS,CAACoD,SAAS,CAC9BC,QAAQ,CAAEpD,QAAQ,CAACqD,IACrB,CAAC,CAAC,CACJ,CAAE,MAAOkB,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,2BAA2B,CAAEA,KAAK,CAAC,CACnD,CACF,CAEA,KAAM,CAAAE,kBAAkBA,CAAClC,SAAS,CAAEiB,SAAS,CAAiB,IAAf,CAAAC,QAAQ,CAAArB,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAG,CAAC,CAAC,CAC1D,KAAM,CAAAsB,SAAS,CAAG,GAAI,CAAAxC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,CAACuD,OAAO,CAAC,OAAO,CAAE,GAAG,CAAC,CAChE,KAAM,CAAAC,QAAQ,cAAA/D,MAAA,CAAgB2B,SAAS,MAAA3B,MAAA,CAAI8C,SAAS,QAAM,CAE1D;AACA,KAAM,CAAAkB,OAAO,CAAG,IAAI,CAACC,aAAa,CAACrB,SAAS,CAAC,CAE7C;AACA,KAAM,CAAAsB,WAAW,CAAG,KAAM,CAAAF,OAAO,CAACE,WAAW,CAAC,CAAC,CAC/C,KAAM,CAAAC,UAAU,CAAGC,IAAI,CAACC,MAAM,CAACC,YAAY,CAAC,GAAG,GAAI,CAAAC,UAAU,CAACL,WAAW,CAAC,CAAC,CAAC,CAE5E,KAAM,CAAAM,SAAS,CAAApE,aAAA,EACbuB,SAAS,CACToC,QAAQ,CACRjB,SAAS,CAAE,GAAI,CAAAxC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,CACnC4C,WAAW,CAAEP,SAAS,CAACnB,MAAM,CAC7BgD,QAAQ,CAAE7B,SAAS,CAACnB,MAAM,CAAG,KAAK,CAAE;AACpCiD,QAAQ,CAAEV,OAAO,CAACW,IAAI,EACnB9B,QAAQ,CACZ,CAED;AACA,KAAM,CAAA3D,UAAU,CAACiD,SAAS,CAAC,CACzBC,IAAI,eAAApC,MAAA,CAAgB+D,QAAQ,CAAE,CAC9B1B,IAAI,CAAE8B,UAAU,CAChB7B,SAAS,CAAEnD,SAAS,CAACoD,SAAS,CAC9BG,SAAS,CAAE,IACb,CAAC,CAAC,CAEF;AACA,KAAM,CAAAkC,YAAY,cAAA5E,MAAA,CAAgB2B,SAAS,MAAA3B,MAAA,CAAI8C,SAAS,SAAO,CAC/D,KAAM,CAAA5D,UAAU,CAACiD,SAAS,CAAC,CACzBC,IAAI,eAAApC,MAAA,CAAgB4E,YAAY,CAAE,CAClCvC,IAAI,CAAEnC,IAAI,CAACC,SAAS,CAACqE,SAAS,CAAE,IAAI,CAAE,CAAC,CAAC,CACxClC,SAAS,CAAEnD,SAAS,CAACoD,SAAS,CAC9BC,QAAQ,CAAEpD,QAAQ,CAACqD,IAAI,CACvBC,SAAS,CAAE,IACb,CAAC,CAAC,CAEF;AACA,KAAM,KAAI,CAACmC,mBAAmB,CAAClD,SAAS,CAAE,WAAW,CAAE6C,SAAS,CAAC,CAEjE,MAAO,CAAET,QAAQ,CAAEa,YAAY,CAAEJ,SAAU,CAAC,CAC9C,CAEA,KAAM,CAAAK,mBAAmBA,CAAClD,SAAS,CAAEI,MAAM,CAAa,IAAX,CAAAM,IAAI,CAAAb,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAG,CAAC,CAAC,CACpD,KAAM,CAAEvB,KAAM,CAAC,CAAG,KAAM,CAAAhB,WAAW,CAACwB,GAAG,CAAC,CAAEV,GAAG,CAAE,IAAI,CAACL,sBAAuB,CAAC,CAAC,CAC7E,KAAM,CAAAsC,QAAQ,CAAG/B,KAAK,CAAGC,IAAI,CAACQ,KAAK,CAACT,KAAK,CAAC,CAAG,EAAE,CAE/C,KAAM,CAAA6E,YAAY,CAAG9C,QAAQ,CAACjB,SAAS,CAACgE,CAAC,EAAIA,CAAC,CAAC9D,EAAE,GAAKU,SAAS,CAAC,CAChE,GAAImD,YAAY,EAAI,CAAC,CAAE,CACrB9C,QAAQ,CAAC8C,YAAY,CAAC,CAAA1E,aAAA,CAAAA,aAAA,IACjB4B,QAAQ,CAAC8C,YAAY,CAAC,MACzB/C,MAAM,CACNiD,OAAO,CAAE,GAAI,CAAA1E,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,EAC9B8B,IAAI,CACR,CAED,KAAM,CAAApD,WAAW,CAACa,GAAG,CAAC,CACpBC,GAAG,CAAE,IAAI,CAACL,sBAAsB,CAChCO,KAAK,CAAEC,IAAI,CAACC,SAAS,CAAC6B,QAAQ,CAChC,CAAC,CAAC,CACJ,CACF,CAEA,KAAM,CAAAiD,oBAAoBA,CAAA,CAAkB,IAAjB,CAAArF,QAAQ,CAAA4B,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAG,IAAI,CACxC,KAAM,CAAEvB,KAAM,CAAC,CAAG,KAAM,CAAAhB,WAAW,CAACwB,GAAG,CAAC,CAAEV,GAAG,CAAE,IAAI,CAACL,sBAAuB,CAAC,CAAC,CAC7E,KAAM,CAAAsC,QAAQ,CAAG/B,KAAK,CAAGC,IAAI,CAACQ,KAAK,CAACT,KAAK,CAAC,CAAG,EAAE,CAE/C,MAAO,CAAAL,QAAQ,CAAGoC,QAAQ,CAACkD,MAAM,CAACH,CAAC,EAAIA,CAAC,CAACnF,QAAQ,GAAKA,QAAQ,CAAC,CAAGoC,QAAQ,CAC5E,CAEA,KAAM,CAAAmD,cAAcA,CAAA,CAAG,CACrB,GAAI,CACF,KAAM,CAAAC,MAAM,CAAG,KAAM,CAAAlG,UAAU,CAACmG,OAAO,CAAC,CACtCjD,IAAI,CAAE,YAAY,CAClBE,SAAS,CAAEnD,SAAS,CAACoD,SACvB,CAAC,CAAC,CAEF,MAAO,CAAA6C,MAAM,CAACE,KAAK,CAACJ,MAAM,CAACK,IAAI,EAC7BA,IAAI,CAACC,IAAI,CAACC,QAAQ,CAAC,MAAM,CAAC,EAAIF,IAAI,CAACC,IAAI,CAACC,QAAQ,CAAC,OAAO,CAC1D,CAAC,CACH,CAAE,MAAO9B,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,2BAA2B,CAAEA,KAAK,CAAC,CACjD,MAAO,EAAE,CACX,CACF,CAEA,KAAM,CAAA+B,YAAYA,CAACd,YAAY,CAAE,CAC/B,GAAI,CACF,KAAM,CAAAQ,MAAM,CAAG,KAAM,CAAAlG,UAAU,CAACyG,QAAQ,CAAC,CACvCvD,IAAI,eAAApC,MAAA,CAAgB4E,YAAY,CAAE,CAClCtC,SAAS,CAAEnD,SAAS,CAACoD,SAAS,CAC9BC,QAAQ,CAAEpD,QAAQ,CAACqD,IACrB,CAAC,CAAC,CAEF,MAAO,CAAAvC,IAAI,CAACQ,KAAK,CAAC0E,MAAM,CAAC/C,IAAI,CAAC,CAChC,CAAE,MAAOsB,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,mCAAmC,CAAEA,KAAK,CAAC,CACzD,MAAO,KAAI,CACb,CACF,CAEA,KAAM,CAAAiC,aAAaA,CAAC7B,QAAQ,CAAE,CAC5B,GAAI,CACF,KAAM,CAAAqB,MAAM,CAAG,KAAM,CAAAlG,UAAU,CAACyG,QAAQ,CAAC,CACvCvD,IAAI,eAAApC,MAAA,CAAgB+D,QAAQ,CAAE,CAC9BzB,SAAS,CAAEnD,SAAS,CAACoD,SACvB,CAAC,CAAC,CAEF;AACA,KAAM,CAAAsD,YAAY,CAAGC,IAAI,CAACV,MAAM,CAAC/C,IAAI,CAAC,CACtC,KAAM,CAAA0D,KAAK,CAAG,GAAI,CAAAxB,UAAU,CAACsB,YAAY,CAACpE,MAAM,CAAC,CACjD,IAAK,GAAI,CAAAuE,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGH,YAAY,CAACpE,MAAM,CAAEuE,CAAC,EAAE,CAAE,CAC5CD,KAAK,CAACC,CAAC,CAAC,CAAGH,YAAY,CAACI,UAAU,CAACD,CAAC,CAAC,CACvC,CAEA,MAAO,IAAI,CAAAE,IAAI,CAAC,CAACH,KAAK,CAAC,CAAE,CAAEI,IAAI,CAAE,WAAY,CAAC,CAAC,CACjD,CAAE,MAAOxC,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,+BAA+B,CAAEA,KAAK,CAAC,CACrD,MAAO,KAAI,CACb,CACF,CAEA,KAAM,CAAAyC,eAAeA,CAACrC,QAAQ,CAAE,CAC9B,GAAI1E,SAAS,CAACgH,gBAAgB,CAAC,CAAC,CAAE,CAChC;AACA;AACA,MAAO,CAAAtC,QAAQ,CACjB,CAAC,IAAM,CACL;AACA,KAAM,CAAAuC,IAAI,CAAG,KAAM,KAAI,CAACV,aAAa,CAAC7B,QAAQ,CAAC,CAC/C,GAAIuC,IAAI,CAAE,CACR,KAAM,CAAAC,GAAG,CAAGC,GAAG,CAACC,eAAe,CAACH,IAAI,CAAC,CACrC,KAAM,CAAAI,CAAC,CAAGC,QAAQ,CAACC,aAAa,CAAC,GAAG,CAAC,CACrCF,CAAC,CAACG,IAAI,CAAGN,GAAG,CACZG,CAAC,CAACI,QAAQ,CAAG/C,QAAQ,CACrB4C,QAAQ,CAACI,IAAI,CAACC,WAAW,CAACN,CAAC,CAAC,CAC5BA,CAAC,CAACO,KAAK,CAAC,CAAC,CACTN,QAAQ,CAACI,IAAI,CAACG,WAAW,CAACR,CAAC,CAAC,CAC5BF,GAAG,CAACW,eAAe,CAACZ,GAAG,CAAC,CAC1B,CACA,MAAO,CAAAxC,QAAQ,CACjB,CACF,CAEA,KAAM,CAAAqD,cAAcA,CAAA,CAAiB,IAAhB,CAAAC,UAAU,CAAA7F,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAG,CAAC,CACjC,KAAM,CAAA8F,UAAU,CAAG,GAAI,CAAAhH,IAAI,CAAC,CAAC,CAC7BgH,UAAU,CAACC,OAAO,CAACD,UAAU,CAACE,OAAO,CAAC,CAAC,CAAGH,UAAU,CAAC,CAErD;AACA,KAAM,CAAArF,QAAQ,CAAG,KAAM,KAAI,CAACiD,oBAAoB,CAAC,CAAC,CAClD,KAAM,CAAAwC,cAAc,CAAGzF,QAAQ,CAACkD,MAAM,CAACH,CAAC,EACtC,GAAI,CAAAzE,IAAI,CAACyE,CAAC,CAACjD,SAAS,CAAC,CAAGwF,UAC1B,CAAC,CAED,KAAM,CAAArI,WAAW,CAACa,GAAG,CAAC,CACpBC,GAAG,CAAE,IAAI,CAACL,sBAAsB,CAChCO,KAAK,CAAEC,IAAI,CAACC,SAAS,CAACsH,cAAc,CACtC,CAAC,CAAC,CAEF;AACA,GAAI,CACF,KAAM,CAAAC,UAAU,CAAG,KAAM,KAAI,CAACvC,cAAc,CAAC,CAAC,CAC9C,IAAK,KAAM,CAAAI,IAAI,GAAI,CAAAmC,UAAU,CAAE,CAC7B,KAAM,CAAAC,IAAI,CAAG,KAAM,CAAAzI,UAAU,CAACyI,IAAI,CAAC,CACjCvF,IAAI,eAAApC,MAAA,CAAgBuF,IAAI,CAACC,IAAI,CAAE,CAC/BlD,SAAS,CAAEnD,SAAS,CAACoD,SACvB,CAAC,CAAC,CAEF,GAAIoF,IAAI,CAACC,KAAK,CAAGN,UAAU,CAACO,OAAO,CAAC,CAAC,CAAE,CACrC,KAAM,CAAA3I,UAAU,CAAC4I,UAAU,CAAC,CAC1B1F,IAAI,eAAApC,MAAA,CAAgBuF,IAAI,CAACC,IAAI,CAAE,CAC/BlD,SAAS,CAAEnD,SAAS,CAACoD,SACvB,CAAC,CAAC,CACFqB,OAAO,CAACmE,GAAG,2BAAA/H,MAAA,CAA2BuF,IAAI,CAACC,IAAI,CAAE,CAAC,CACpD,CACF,CACF,CAAE,MAAO7B,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,6BAA6B,CAAEA,KAAK,CAAC,CACrD,CACF,CAEA;AACAM,aAAaA,CAACrB,SAAS,CAAE,CACvB,KAAM,CAAAoF,WAAW,CAAG,KAAK,CACzB,KAAM,CAAAC,QAAQ,CAAG,CAAC,CAClB,KAAM,CAAAC,YAAY,CAAG,CAAC,CAEtB,KAAM,CAAAC,MAAM,CAAG,GAAI,CAAAC,WAAW,CAAC,EAAE,CAAGxF,SAAS,CAACnB,MAAM,CAAG,CAAC,CAAC,CACzD,KAAM,CAAA4G,IAAI,CAAG,GAAI,CAAAC,QAAQ,CAACH,MAAM,CAAC,CAEjC;AACA,KAAM,CAAAI,WAAW,CAAGA,CAACC,MAAM,CAAEC,MAAM,GAAK,CACtC,IAAK,GAAI,CAAAzC,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGyC,MAAM,CAAChH,MAAM,CAAEuE,CAAC,EAAE,CAAE,CACtCqC,IAAI,CAACK,QAAQ,CAACF,MAAM,CAAGxC,CAAC,CAAEyC,MAAM,CAACxC,UAAU,CAACD,CAAC,CAAC,CAAC,CACjD,CACF,CAAC,CAEDuC,WAAW,CAAC,CAAC,CAAE,MAAM,CAAC,CACtBF,IAAI,CAACM,SAAS,CAAC,CAAC,CAAE,EAAE,CAAG/F,SAAS,CAACnB,MAAM,CAAG,CAAC,CAAE,IAAI,CAAC,CAClD8G,WAAW,CAAC,CAAC,CAAE,MAAM,CAAC,CACtBA,WAAW,CAAC,EAAE,CAAE,MAAM,CAAC,CACvBF,IAAI,CAACM,SAAS,CAAC,EAAE,CAAE,EAAE,CAAE,IAAI,CAAC,CAC5BN,IAAI,CAACO,SAAS,CAAC,EAAE,CAAE,CAAC,CAAE,IAAI,CAAC,CAC3BP,IAAI,CAACO,SAAS,CAAC,EAAE,CAAEX,QAAQ,CAAE,IAAI,CAAC,CAClCI,IAAI,CAACM,SAAS,CAAC,EAAE,CAAEX,WAAW,CAAE,IAAI,CAAC,CACrCK,IAAI,CAACM,SAAS,CAAC,EAAE,CAAEX,WAAW,CAAGC,QAAQ,CAAGC,YAAY,CAAE,IAAI,CAAC,CAC/DG,IAAI,CAACO,SAAS,CAAC,EAAE,CAAEX,QAAQ,CAAGC,YAAY,CAAE,IAAI,CAAC,CACjDG,IAAI,CAACO,SAAS,CAAC,EAAE,CAAE,EAAE,CAAE,IAAI,CAAC,CAC5BL,WAAW,CAAC,EAAE,CAAE,MAAM,CAAC,CACvBF,IAAI,CAACM,SAAS,CAAC,EAAE,CAAE/F,SAAS,CAACnB,MAAM,CAAG,CAAC,CAAE,IAAI,CAAC,CAE9C;AACA,GAAI,CAAA+G,MAAM,CAAG,EAAE,CACf,IAAK,GAAI,CAAAxC,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGpD,SAAS,CAACnB,MAAM,CAAEuE,CAAC,EAAE,CAAE,CACzCqC,IAAI,CAACQ,QAAQ,CAACL,MAAM,CAAE5F,SAAS,CAACoD,CAAC,CAAC,CAAE,IAAI,CAAC,CACzCwC,MAAM,EAAI,CAAC,CACb,CAEA,MAAO,IAAI,CAAAtC,IAAI,CAAC,CAACiC,MAAM,CAAC,CAAE,CAAEhC,IAAI,CAAE,WAAY,CAAC,CAAC,CAClD,CAEA,KAAM,CAAA2C,YAAYA,CAAA,CAAG,CACnB;AACA,KAAM,CAAA7J,WAAW,CAAC8J,KAAK,CAAC,CAAC,CAEzB;AACA,GAAI,CACF,KAAM,CAAA7J,UAAU,CAAC8J,KAAK,CAAC,CACrB5G,IAAI,CAAE,YAAY,CAClBE,SAAS,CAAEnD,SAAS,CAACoD,SAAS,CAC9BG,SAAS,CAAE,IACb,CAAC,CAAC,CACF,KAAM,CAAAxD,UAAU,CAAC8J,KAAK,CAAC,CACrB5G,IAAI,CAAE,YAAY,CAClBE,SAAS,CAAEnD,SAAS,CAACoD,SAAS,CAC9BG,SAAS,CAAE,IACb,CAAC,CAAC,CACJ,CAAE,MAAOiB,KAAK,CAAE,CACdC,OAAO,CAACmE,GAAG,CAAC,iCAAiC,CAAEpE,KAAK,CAAC,CACvD,CACF,CACF,CAEA;AACA,MAAO,MAAM,CAAAsF,mBAAmB,CAAG,GAAI,CAAA3J,mBAAmB,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}