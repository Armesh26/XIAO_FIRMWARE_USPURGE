{"ast":null,"code":"import { WebPlugin } from '@capacitor/core';\nimport { hexStringToDataView, mapToObject, webUUIDToString } from './conversion';\nimport { runWithTimeout } from './timeout';\nexport class BluetoothLeWeb extends WebPlugin {\n  constructor() {\n    super(...arguments);\n    this.deviceMap = new Map();\n    this.discoveredDevices = new Map();\n    this.scan = null;\n    this.DEFAULT_CONNECTION_TIMEOUT = 10000;\n    this.onAdvertisementReceivedCallback = this.onAdvertisementReceived.bind(this);\n    this.onDisconnectedCallback = this.onDisconnected.bind(this);\n    this.onCharacteristicValueChangedCallback = this.onCharacteristicValueChanged.bind(this);\n  }\n  async initialize() {\n    if (typeof navigator === 'undefined' || !navigator.bluetooth) {\n      throw this.unavailable('Web Bluetooth API not available in this browser.');\n    }\n    const isAvailable = await navigator.bluetooth.getAvailability();\n    if (!isAvailable) {\n      throw this.unavailable('No Bluetooth radio available.');\n    }\n  }\n  async isEnabled() {\n    // not available on web\n    return {\n      value: true\n    };\n  }\n  async requestEnable() {\n    throw this.unavailable('requestEnable is not available on web.');\n  }\n  async enable() {\n    throw this.unavailable('enable is not available on web.');\n  }\n  async disable() {\n    throw this.unavailable('disable is not available on web.');\n  }\n  async startEnabledNotifications() {\n    // not available on web\n  }\n  async stopEnabledNotifications() {\n    // not available on web\n  }\n  async isLocationEnabled() {\n    throw this.unavailable('isLocationEnabled is not available on web.');\n  }\n  async openLocationSettings() {\n    throw this.unavailable('openLocationSettings is not available on web.');\n  }\n  async openBluetoothSettings() {\n    throw this.unavailable('openBluetoothSettings is not available on web.');\n  }\n  async openAppSettings() {\n    throw this.unavailable('openAppSettings is not available on web.');\n  }\n  async setDisplayStrings() {\n    // not available on web\n  }\n  async requestDevice(options) {\n    const filters = this.getFilters(options);\n    const device = await navigator.bluetooth.requestDevice({\n      filters: filters.length ? filters : undefined,\n      optionalServices: options === null || options === void 0 ? void 0 : options.optionalServices,\n      acceptAllDevices: filters.length === 0\n    });\n    this.deviceMap.set(device.id, device);\n    const bleDevice = this.getBleDevice(device);\n    return bleDevice;\n  }\n  async requestLEScan(options) {\n    this.requestBleDeviceOptions = options;\n    const filters = this.getFilters(options);\n    await this.stopLEScan();\n    this.discoveredDevices = new Map();\n    navigator.bluetooth.removeEventListener('advertisementreceived', this.onAdvertisementReceivedCallback);\n    navigator.bluetooth.addEventListener('advertisementreceived', this.onAdvertisementReceivedCallback);\n    this.scan = await navigator.bluetooth.requestLEScan({\n      filters: filters.length ? filters : undefined,\n      acceptAllAdvertisements: filters.length === 0,\n      keepRepeatedDevices: options === null || options === void 0 ? void 0 : options.allowDuplicates\n    });\n  }\n  onAdvertisementReceived(event) {\n    var _a, _b;\n    const deviceId = event.device.id;\n    this.deviceMap.set(deviceId, event.device);\n    const isNew = !this.discoveredDevices.has(deviceId);\n    if (isNew || ((_a = this.requestBleDeviceOptions) === null || _a === void 0 ? void 0 : _a.allowDuplicates)) {\n      this.discoveredDevices.set(deviceId, true);\n      const device = this.getBleDevice(event.device);\n      const result = {\n        device,\n        localName: device.name,\n        rssi: event.rssi,\n        txPower: event.txPower,\n        manufacturerData: mapToObject(event.manufacturerData),\n        serviceData: mapToObject(event.serviceData),\n        uuids: (_b = event.uuids) === null || _b === void 0 ? void 0 : _b.map(webUUIDToString)\n      };\n      this.notifyListeners('onScanResult', result);\n    }\n  }\n  async stopLEScan() {\n    var _a;\n    if ((_a = this.scan) === null || _a === void 0 ? void 0 : _a.active) {\n      this.scan.stop();\n    }\n    this.scan = null;\n  }\n  async getDevices(options) {\n    const devices = await navigator.bluetooth.getDevices();\n    const bleDevices = devices.filter(device => options.deviceIds.includes(device.id)).map(device => {\n      this.deviceMap.set(device.id, device);\n      const bleDevice = this.getBleDevice(device);\n      return bleDevice;\n    });\n    return {\n      devices: bleDevices\n    };\n  }\n  async getConnectedDevices(_options) {\n    const devices = await navigator.bluetooth.getDevices();\n    const bleDevices = devices.filter(device => {\n      var _a;\n      return (_a = device.gatt) === null || _a === void 0 ? void 0 : _a.connected;\n    }).map(device => {\n      this.deviceMap.set(device.id, device);\n      const bleDevice = this.getBleDevice(device);\n      return bleDevice;\n    });\n    return {\n      devices: bleDevices\n    };\n  }\n  async getBondedDevices() {\n    return {};\n  }\n  async connect(options) {\n    var _a, _b;\n    const device = this.getDeviceFromMap(options.deviceId);\n    device.removeEventListener('gattserverdisconnected', this.onDisconnectedCallback);\n    device.addEventListener('gattserverdisconnected', this.onDisconnectedCallback);\n    const timeoutError = Symbol();\n    if (device.gatt === undefined) {\n      throw new Error('No gatt server available.');\n    }\n    try {\n      const timeout = (_a = options.timeout) !== null && _a !== void 0 ? _a : this.DEFAULT_CONNECTION_TIMEOUT;\n      await runWithTimeout(device.gatt.connect(), timeout, timeoutError);\n    } catch (error) {\n      // cancel pending connect call, does not work yet in chromium because of a bug:\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=684073\n      await ((_b = device.gatt) === null || _b === void 0 ? void 0 : _b.disconnect());\n      if (error === timeoutError) {\n        throw new Error('Connection timeout');\n      } else {\n        throw error;\n      }\n    }\n  }\n  onDisconnected(event) {\n    const deviceId = event.target.id;\n    const key = \"disconnected|\".concat(deviceId);\n    this.notifyListeners(key, null);\n  }\n  async createBond(_options) {\n    throw this.unavailable('createBond is not available on web.');\n  }\n  async isBonded(_options) {\n    throw this.unavailable('isBonded is not available on web.');\n  }\n  async disconnect(options) {\n    var _a;\n    (_a = this.getDeviceFromMap(options.deviceId).gatt) === null || _a === void 0 ? void 0 : _a.disconnect();\n  }\n  async getServices(options) {\n    var _a, _b;\n    const services = (_b = await ((_a = this.getDeviceFromMap(options.deviceId).gatt) === null || _a === void 0 ? void 0 : _a.getPrimaryServices())) !== null && _b !== void 0 ? _b : [];\n    const bleServices = [];\n    for (const service of services) {\n      const characteristics = await service.getCharacteristics();\n      const bleCharacteristics = [];\n      for (const characteristic of characteristics) {\n        bleCharacteristics.push({\n          uuid: characteristic.uuid,\n          properties: this.getProperties(characteristic),\n          descriptors: await this.getDescriptors(characteristic)\n        });\n      }\n      bleServices.push({\n        uuid: service.uuid,\n        characteristics: bleCharacteristics\n      });\n    }\n    return {\n      services: bleServices\n    };\n  }\n  async getDescriptors(characteristic) {\n    try {\n      const descriptors = await characteristic.getDescriptors();\n      return descriptors.map(descriptor => ({\n        uuid: descriptor.uuid\n      }));\n    } catch (_a) {\n      return [];\n    }\n  }\n  getProperties(characteristic) {\n    return {\n      broadcast: characteristic.properties.broadcast,\n      read: characteristic.properties.read,\n      writeWithoutResponse: characteristic.properties.writeWithoutResponse,\n      write: characteristic.properties.write,\n      notify: characteristic.properties.notify,\n      indicate: characteristic.properties.indicate,\n      authenticatedSignedWrites: characteristic.properties.authenticatedSignedWrites,\n      reliableWrite: characteristic.properties.reliableWrite,\n      writableAuxiliaries: characteristic.properties.writableAuxiliaries\n    };\n  }\n  async getCharacteristic(options) {\n    var _a;\n    const service = await ((_a = this.getDeviceFromMap(options.deviceId).gatt) === null || _a === void 0 ? void 0 : _a.getPrimaryService(options === null || options === void 0 ? void 0 : options.service));\n    return service === null || service === void 0 ? void 0 : service.getCharacteristic(options === null || options === void 0 ? void 0 : options.characteristic);\n  }\n  async getDescriptor(options) {\n    const characteristic = await this.getCharacteristic(options);\n    return characteristic === null || characteristic === void 0 ? void 0 : characteristic.getDescriptor(options === null || options === void 0 ? void 0 : options.descriptor);\n  }\n  async discoverServices(_options) {\n    throw this.unavailable('discoverServices is not available on web.');\n  }\n  async getMtu(_options) {\n    throw this.unavailable('getMtu is not available on web.');\n  }\n  async requestConnectionPriority(_options) {\n    throw this.unavailable('requestConnectionPriority is not available on web.');\n  }\n  async readRssi(_options) {\n    throw this.unavailable('readRssi is not available on web.');\n  }\n  async read(options) {\n    const characteristic = await this.getCharacteristic(options);\n    const value = await (characteristic === null || characteristic === void 0 ? void 0 : characteristic.readValue());\n    return {\n      value\n    };\n  }\n  async write(options) {\n    const characteristic = await this.getCharacteristic(options);\n    let dataView;\n    if (typeof options.value === 'string') {\n      dataView = hexStringToDataView(options.value);\n    } else {\n      dataView = options.value;\n    }\n    await (characteristic === null || characteristic === void 0 ? void 0 : characteristic.writeValueWithResponse(dataView));\n  }\n  async writeWithoutResponse(options) {\n    const characteristic = await this.getCharacteristic(options);\n    let dataView;\n    if (typeof options.value === 'string') {\n      dataView = hexStringToDataView(options.value);\n    } else {\n      dataView = options.value;\n    }\n    await (characteristic === null || characteristic === void 0 ? void 0 : characteristic.writeValueWithoutResponse(dataView));\n  }\n  async readDescriptor(options) {\n    const descriptor = await this.getDescriptor(options);\n    const value = await (descriptor === null || descriptor === void 0 ? void 0 : descriptor.readValue());\n    return {\n      value\n    };\n  }\n  async writeDescriptor(options) {\n    const descriptor = await this.getDescriptor(options);\n    let dataView;\n    if (typeof options.value === 'string') {\n      dataView = hexStringToDataView(options.value);\n    } else {\n      dataView = options.value;\n    }\n    await (descriptor === null || descriptor === void 0 ? void 0 : descriptor.writeValue(dataView));\n  }\n  async startNotifications(options) {\n    const characteristic = await this.getCharacteristic(options);\n    characteristic === null || characteristic === void 0 ? void 0 : characteristic.removeEventListener('characteristicvaluechanged', this.onCharacteristicValueChangedCallback);\n    characteristic === null || characteristic === void 0 ? void 0 : characteristic.addEventListener('characteristicvaluechanged', this.onCharacteristicValueChangedCallback);\n    await (characteristic === null || characteristic === void 0 ? void 0 : characteristic.startNotifications());\n  }\n  onCharacteristicValueChanged(event) {\n    var _a, _b;\n    const characteristic = event.target;\n    const key = \"notification|\".concat((_a = characteristic.service) === null || _a === void 0 ? void 0 : _a.device.id, \"|\").concat((_b = characteristic.service) === null || _b === void 0 ? void 0 : _b.uuid, \"|\").concat(characteristic.uuid);\n    this.notifyListeners(key, {\n      value: characteristic.value\n    });\n  }\n  async stopNotifications(options) {\n    const characteristic = await this.getCharacteristic(options);\n    await (characteristic === null || characteristic === void 0 ? void 0 : characteristic.stopNotifications());\n  }\n  getFilters(options) {\n    var _a, _b;\n    const filters = [];\n    for (const service of (_a = options === null || options === void 0 ? void 0 : options.services) !== null && _a !== void 0 ? _a : []) {\n      filters.push({\n        services: [service],\n        name: options === null || options === void 0 ? void 0 : options.name,\n        namePrefix: options === null || options === void 0 ? void 0 : options.namePrefix\n      });\n    }\n    if (((options === null || options === void 0 ? void 0 : options.name) || (options === null || options === void 0 ? void 0 : options.namePrefix)) && filters.length === 0) {\n      filters.push({\n        name: options.name,\n        namePrefix: options.namePrefix\n      });\n    }\n    for (const manufacturerData of (_b = options === null || options === void 0 ? void 0 : options.manufacturerData) !== null && _b !== void 0 ? _b : []) {\n      filters.push({\n        manufacturerData: [manufacturerData]\n      });\n    }\n    return filters;\n  }\n  getDeviceFromMap(deviceId) {\n    const device = this.deviceMap.get(deviceId);\n    if (device === undefined) {\n      throw new Error('Device not found. Call \"requestDevice\", \"requestLEScan\" or \"getDevices\" first.');\n    }\n    return device;\n  }\n  getBleDevice(device) {\n    var _a;\n    const bleDevice = {\n      deviceId: device.id,\n      // use undefined instead of null if name is not available\n      name: (_a = device.name) !== null && _a !== void 0 ? _a : undefined\n    };\n    return bleDevice;\n  }\n}","map":{"version":3,"names":["WebPlugin","hexStringToDataView","mapToObject","webUUIDToString","runWithTimeout","BluetoothLeWeb","constructor","deviceMap","Map","discoveredDevices","scan","DEFAULT_CONNECTION_TIMEOUT","onAdvertisementReceivedCallback","onAdvertisementReceived","bind","onDisconnectedCallback","onDisconnected","onCharacteristicValueChangedCallback","onCharacteristicValueChanged","initialize","navigator","bluetooth","unavailable","isAvailable","getAvailability","isEnabled","value","requestEnable","enable","disable","startEnabledNotifications","stopEnabledNotifications","isLocationEnabled","openLocationSettings","openBluetoothSettings","openAppSettings","setDisplayStrings","requestDevice","options","filters","getFilters","device","length","undefined","optionalServices","acceptAllDevices","set","id","bleDevice","getBleDevice","requestLEScan","requestBleDeviceOptions","stopLEScan","removeEventListener","addEventListener","acceptAllAdvertisements","keepRepeatedDevices","allowDuplicates","event","deviceId","isNew","has","_a","result","localName","name","rssi","txPower","manufacturerData","serviceData","uuids","_b","map","notifyListeners","active","stop","getDevices","devices","bleDevices","filter","deviceIds","includes","getConnectedDevices","_options","gatt","connected","getBondedDevices","connect","getDeviceFromMap","timeoutError","Symbol","Error","timeout","error","disconnect","target","key","concat","createBond","isBonded","getServices","services","getPrimaryServices","bleServices","service","characteristics","getCharacteristics","bleCharacteristics","characteristic","push","uuid","properties","getProperties","descriptors","getDescriptors","descriptor","broadcast","read","writeWithoutResponse","write","notify","indicate","authenticatedSignedWrites","reliableWrite","writableAuxiliaries","getCharacteristic","getPrimaryService","getDescriptor","discoverServices","getMtu","requestConnectionPriority","readRssi","readValue","dataView","writeValueWithResponse","writeValueWithoutResponse","readDescriptor","writeDescriptor","writeValue","startNotifications","stopNotifications","namePrefix","get"],"sources":["/Users/armeshpereira/Documents/LastAttempt/reactapp/node_modules/@capacitor-community/bluetooth-le/src/web.ts"],"sourcesContent":["import { WebPlugin } from '@capacitor/core';\n\nimport { hexStringToDataView, mapToObject, webUUIDToString } from './conversion';\nimport type {\n  BleCharacteristic,\n  BleCharacteristicProperties,\n  BleDescriptor,\n  BleService,\n  TimeoutOptions,\n  BleDevice,\n  BleServices,\n  BluetoothLePlugin,\n  BooleanResult,\n  DeviceIdOptions,\n  GetConnectedDevicesOptions,\n  GetDevicesOptions,\n  GetDevicesResult,\n  ReadDescriptorOptions,\n  ReadOptions,\n  ReadResult,\n  ReadRssiResult,\n  RequestBleDeviceOptions,\n  ScanResultInternal,\n  WriteOptions,\n  WriteDescriptorOptions,\n  GetMtuResult,\n  RequestConnectionPriorityOptions,\n} from './definitions';\nimport { runWithTimeout } from './timeout';\n\nexport class BluetoothLeWeb extends WebPlugin implements BluetoothLePlugin {\n  private deviceMap = new Map<string, BluetoothDevice>();\n  private discoveredDevices = new Map<string, boolean>();\n  private scan: BluetoothLEScan | null = null;\n  private requestBleDeviceOptions: RequestBleDeviceOptions | undefined;\n  private DEFAULT_CONNECTION_TIMEOUT = 10000;\n\n  async initialize(): Promise<void> {\n    if (typeof navigator === 'undefined' || !navigator.bluetooth) {\n      throw this.unavailable('Web Bluetooth API not available in this browser.');\n    }\n    const isAvailable = await navigator.bluetooth.getAvailability();\n    if (!isAvailable) {\n      throw this.unavailable('No Bluetooth radio available.');\n    }\n  }\n\n  async isEnabled(): Promise<BooleanResult> {\n    // not available on web\n    return { value: true };\n  }\n\n  async requestEnable(): Promise<void> {\n    throw this.unavailable('requestEnable is not available on web.');\n  }\n\n  async enable(): Promise<void> {\n    throw this.unavailable('enable is not available on web.');\n  }\n\n  async disable(): Promise<void> {\n    throw this.unavailable('disable is not available on web.');\n  }\n\n  async startEnabledNotifications(): Promise<void> {\n    // not available on web\n  }\n\n  async stopEnabledNotifications(): Promise<void> {\n    // not available on web\n  }\n\n  async isLocationEnabled(): Promise<BooleanResult> {\n    throw this.unavailable('isLocationEnabled is not available on web.');\n  }\n\n  async openLocationSettings(): Promise<void> {\n    throw this.unavailable('openLocationSettings is not available on web.');\n  }\n\n  async openBluetoothSettings(): Promise<void> {\n    throw this.unavailable('openBluetoothSettings is not available on web.');\n  }\n\n  async openAppSettings(): Promise<void> {\n    throw this.unavailable('openAppSettings is not available on web.');\n  }\n\n  async setDisplayStrings(): Promise<void> {\n    // not available on web\n  }\n\n  async requestDevice(options?: RequestBleDeviceOptions): Promise<BleDevice> {\n    const filters = this.getFilters(options);\n    const device = await navigator.bluetooth.requestDevice({\n      filters: filters.length ? filters : undefined,\n      optionalServices: options?.optionalServices,\n      acceptAllDevices: filters.length === 0,\n    });\n    this.deviceMap.set(device.id, device);\n    const bleDevice = this.getBleDevice(device);\n    return bleDevice;\n  }\n\n  async requestLEScan(options?: RequestBleDeviceOptions): Promise<void> {\n    this.requestBleDeviceOptions = options;\n    const filters = this.getFilters(options);\n    await this.stopLEScan();\n    this.discoveredDevices = new Map<string, boolean>();\n    navigator.bluetooth.removeEventListener(\n      'advertisementreceived',\n      this.onAdvertisementReceivedCallback as EventListener,\n    );\n    navigator.bluetooth.addEventListener('advertisementreceived', this.onAdvertisementReceivedCallback);\n    this.scan = await navigator.bluetooth.requestLEScan({\n      filters: filters.length ? filters : undefined,\n      acceptAllAdvertisements: filters.length === 0,\n      keepRepeatedDevices: options?.allowDuplicates,\n    });\n  }\n\n  private onAdvertisementReceivedCallback = this.onAdvertisementReceived.bind(this);\n\n  private onAdvertisementReceived(event: BluetoothAdvertisingEvent): void {\n    const deviceId = event.device.id;\n    this.deviceMap.set(deviceId, event.device);\n    const isNew = !this.discoveredDevices.has(deviceId);\n    if (isNew || this.requestBleDeviceOptions?.allowDuplicates) {\n      this.discoveredDevices.set(deviceId, true);\n      const device = this.getBleDevice(event.device);\n      const result: ScanResultInternal = {\n        device,\n        localName: device.name,\n        rssi: event.rssi,\n        txPower: event.txPower,\n        manufacturerData: mapToObject(event.manufacturerData),\n        serviceData: mapToObject(event.serviceData),\n        uuids: event.uuids?.map(webUUIDToString),\n      };\n      this.notifyListeners('onScanResult', result);\n    }\n  }\n\n  async stopLEScan(): Promise<void> {\n    if (this.scan?.active) {\n      this.scan.stop();\n    }\n    this.scan = null;\n  }\n\n  async getDevices(options: GetDevicesOptions): Promise<GetDevicesResult> {\n    const devices = await navigator.bluetooth.getDevices();\n    const bleDevices = devices\n      .filter((device) => options.deviceIds.includes(device.id))\n      .map((device) => {\n        this.deviceMap.set(device.id, device);\n        const bleDevice = this.getBleDevice(device);\n        return bleDevice;\n      });\n    return { devices: bleDevices };\n  }\n\n  async getConnectedDevices(_options: GetConnectedDevicesOptions): Promise<GetDevicesResult> {\n    const devices = await navigator.bluetooth.getDevices();\n    const bleDevices = devices\n      .filter((device) => {\n        return device.gatt?.connected;\n      })\n      .map((device) => {\n        this.deviceMap.set(device.id, device);\n        const bleDevice = this.getBleDevice(device);\n        return bleDevice;\n      });\n    return { devices: bleDevices };\n  }\n\n  async getBondedDevices(): Promise<GetDevicesResult> {\n    return {} as Promise<GetDevicesResult>;\n  }\n\n  async connect(options: DeviceIdOptions & TimeoutOptions): Promise<void> {\n    const device = this.getDeviceFromMap(options.deviceId);\n    device.removeEventListener('gattserverdisconnected', this.onDisconnectedCallback);\n    device.addEventListener('gattserverdisconnected', this.onDisconnectedCallback);\n    const timeoutError = Symbol();\n    if (device.gatt === undefined) {\n      throw new Error('No gatt server available.');\n    }\n    try {\n      const timeout = options.timeout ?? this.DEFAULT_CONNECTION_TIMEOUT;\n      await runWithTimeout(device.gatt.connect(), timeout, timeoutError);\n    } catch (error) {\n      // cancel pending connect call, does not work yet in chromium because of a bug:\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=684073\n      await device.gatt?.disconnect();\n      if (error === timeoutError) {\n        throw new Error('Connection timeout');\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  private onDisconnectedCallback = this.onDisconnected.bind(this);\n\n  private onDisconnected(event: Event): void {\n    const deviceId = (event.target as BluetoothDevice).id;\n    const key = `disconnected|${deviceId}`;\n    this.notifyListeners(key, null);\n  }\n\n  async createBond(_options: DeviceIdOptions): Promise<void> {\n    throw this.unavailable('createBond is not available on web.');\n  }\n\n  async isBonded(_options: DeviceIdOptions): Promise<BooleanResult> {\n    throw this.unavailable('isBonded is not available on web.');\n  }\n\n  async disconnect(options: DeviceIdOptions): Promise<void> {\n    this.getDeviceFromMap(options.deviceId).gatt?.disconnect();\n  }\n\n  async getServices(options: DeviceIdOptions): Promise<BleServices> {\n    const services = (await this.getDeviceFromMap(options.deviceId).gatt?.getPrimaryServices()) ?? [];\n    const bleServices: BleService[] = [];\n    for (const service of services) {\n      const characteristics = await service.getCharacteristics();\n      const bleCharacteristics: BleCharacteristic[] = [];\n      for (const characteristic of characteristics) {\n        bleCharacteristics.push({\n          uuid: characteristic.uuid,\n          properties: this.getProperties(characteristic),\n          descriptors: await this.getDescriptors(characteristic),\n        });\n      }\n      bleServices.push({ uuid: service.uuid, characteristics: bleCharacteristics });\n    }\n    return { services: bleServices };\n  }\n\n  private async getDescriptors(characteristic: BluetoothRemoteGATTCharacteristic): Promise<BleDescriptor[]> {\n    try {\n      const descriptors = await characteristic.getDescriptors();\n      return descriptors.map((descriptor) => ({\n        uuid: descriptor.uuid,\n      }));\n    } catch {\n      return [];\n    }\n  }\n\n  private getProperties(characteristic: BluetoothRemoteGATTCharacteristic): BleCharacteristicProperties {\n    return {\n      broadcast: characteristic.properties.broadcast,\n      read: characteristic.properties.read,\n      writeWithoutResponse: characteristic.properties.writeWithoutResponse,\n      write: characteristic.properties.write,\n      notify: characteristic.properties.notify,\n      indicate: characteristic.properties.indicate,\n      authenticatedSignedWrites: characteristic.properties.authenticatedSignedWrites,\n      reliableWrite: characteristic.properties.reliableWrite,\n      writableAuxiliaries: characteristic.properties.writableAuxiliaries,\n    };\n  }\n\n  private async getCharacteristic(\n    options: ReadOptions | WriteOptions,\n  ): Promise<BluetoothRemoteGATTCharacteristic | undefined> {\n    const service = await this.getDeviceFromMap(options.deviceId).gatt?.getPrimaryService(options?.service);\n    return service?.getCharacteristic(options?.characteristic);\n  }\n\n  private async getDescriptor(\n    options: ReadDescriptorOptions | WriteDescriptorOptions,\n  ): Promise<BluetoothRemoteGATTDescriptor | undefined> {\n    const characteristic = await this.getCharacteristic(options);\n    return characteristic?.getDescriptor(options?.descriptor);\n  }\n\n  async discoverServices(_options: DeviceIdOptions): Promise<void> {\n    throw this.unavailable('discoverServices is not available on web.');\n  }\n\n  async getMtu(_options: DeviceIdOptions): Promise<GetMtuResult> {\n    throw this.unavailable('getMtu is not available on web.');\n  }\n\n  async requestConnectionPriority(_options: RequestConnectionPriorityOptions): Promise<void> {\n    throw this.unavailable('requestConnectionPriority is not available on web.');\n  }\n\n  async readRssi(_options: DeviceIdOptions): Promise<ReadRssiResult> {\n    throw this.unavailable('readRssi is not available on web.');\n  }\n\n  async read(options: ReadOptions): Promise<ReadResult> {\n    const characteristic = await this.getCharacteristic(options);\n    const value = await characteristic?.readValue();\n    return { value };\n  }\n\n  async write(options: WriteOptions): Promise<void> {\n    const characteristic = await this.getCharacteristic(options);\n    let dataView: DataView;\n    if (typeof options.value === 'string') {\n      dataView = hexStringToDataView(options.value);\n    } else {\n      dataView = options.value;\n    }\n    await characteristic?.writeValueWithResponse(dataView);\n  }\n\n  async writeWithoutResponse(options: WriteOptions): Promise<void> {\n    const characteristic = await this.getCharacteristic(options);\n    let dataView: DataView;\n    if (typeof options.value === 'string') {\n      dataView = hexStringToDataView(options.value);\n    } else {\n      dataView = options.value;\n    }\n    await characteristic?.writeValueWithoutResponse(dataView);\n  }\n\n  async readDescriptor(options: ReadDescriptorOptions): Promise<ReadResult> {\n    const descriptor = await this.getDescriptor(options);\n    const value = await descriptor?.readValue();\n    return { value };\n  }\n\n  async writeDescriptor(options: WriteDescriptorOptions): Promise<void> {\n    const descriptor = await this.getDescriptor(options);\n    let dataView: DataView;\n    if (typeof options.value === 'string') {\n      dataView = hexStringToDataView(options.value);\n    } else {\n      dataView = options.value;\n    }\n    await descriptor?.writeValue(dataView);\n  }\n\n  async startNotifications(options: ReadOptions): Promise<void> {\n    const characteristic = await this.getCharacteristic(options);\n    characteristic?.removeEventListener('characteristicvaluechanged', this.onCharacteristicValueChangedCallback);\n    characteristic?.addEventListener('characteristicvaluechanged', this.onCharacteristicValueChangedCallback);\n    await characteristic?.startNotifications();\n  }\n\n  private onCharacteristicValueChangedCallback = this.onCharacteristicValueChanged.bind(this);\n\n  private onCharacteristicValueChanged(event: Event): void {\n    const characteristic = event.target as BluetoothRemoteGATTCharacteristic;\n    const key = `notification|${characteristic.service?.device.id}|${characteristic.service?.uuid}|${characteristic.uuid}`;\n    this.notifyListeners(key, {\n      value: characteristic.value,\n    });\n  }\n\n  async stopNotifications(options: ReadOptions): Promise<void> {\n    const characteristic = await this.getCharacteristic(options);\n    await characteristic?.stopNotifications();\n  }\n\n  private getFilters(options?: RequestBleDeviceOptions): BluetoothLEScanFilter[] {\n    const filters: BluetoothLEScanFilter[] = [];\n    for (const service of options?.services ?? []) {\n      filters.push({\n        services: [service],\n        name: options?.name,\n        namePrefix: options?.namePrefix,\n      });\n    }\n    if ((options?.name || options?.namePrefix) && filters.length === 0) {\n      filters.push({\n        name: options.name,\n        namePrefix: options.namePrefix,\n      });\n    }\n    for (const manufacturerData of options?.manufacturerData ?? []) {\n      filters.push({\n        manufacturerData: [manufacturerData],\n      });\n    }\n    return filters;\n  }\n\n  private getDeviceFromMap(deviceId: string): BluetoothDevice {\n    const device = this.deviceMap.get(deviceId);\n    if (device === undefined) {\n      throw new Error('Device not found. Call \"requestDevice\", \"requestLEScan\" or \"getDevices\" first.');\n    }\n    return device;\n  }\n\n  private getBleDevice(device: BluetoothDevice): BleDevice {\n    const bleDevice: BleDevice = {\n      deviceId: device.id,\n      // use undefined instead of null if name is not available\n      name: device.name ?? undefined,\n    };\n    return bleDevice;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}