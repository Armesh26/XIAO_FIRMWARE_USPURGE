{"ast":null,"code":"import { DEFAULT_AGENT_URL } from \"../lib/constants\";\nimport { AgentEvents } from \"../lib/enums/AgentEvents\";\nimport { DeepgramError } from \"../lib/errors\";\nimport { AbstractLiveClient } from \"./AbstractLiveClient\";\nexport class AgentLiveClient extends AbstractLiveClient {\n  constructor(options, endpoint = \"/:version/agent/converse\") {\n    var _a, _b, _c, _d;\n    super(options);\n    this.namespace = \"agent\";\n    this.baseUrl = (_d = (_c = (_b = (_a = options.agent) === null || _a === void 0 ? void 0 : _a.websocket) === null || _b === void 0 ? void 0 : _b.options) === null || _c === void 0 ? void 0 : _c.url) !== null && _d !== void 0 ? _d : DEFAULT_AGENT_URL;\n    this.connect({}, endpoint);\n  }\n  /**\n   * Sets up the connection event handlers.\n   * This method is responsible for handling the various events that can occur on the WebSocket connection, such as opening, closing, and receiving messages.\n   * - When the connection is opened, it emits the `AgentEvents.Open` event.\n   * - When the connection is closed, it emits the `AgentEvents.Close` event.\n   * - When an error occurs on the connection, it emits the `AgentEvents.Error` event.\n   * - When a message is received, it parses the message and emits the appropriate event based on the message type.\n   */\n  setupConnection() {\n    if (this.conn) {\n      this.conn.onopen = () => {\n        this.emit(AgentEvents.Open, this);\n      };\n      this.conn.onclose = event => {\n        this.emit(AgentEvents.Close, event);\n      };\n      this.conn.onerror = event => {\n        this.emit(AgentEvents.Error, event);\n      };\n      this.conn.onmessage = event => {\n        this.handleMessage(event);\n      };\n    }\n  }\n  /**\n   * Handles incoming messages from the WebSocket connection.\n   * @param event - The MessageEvent object representing the received message.\n   */\n  handleMessage(event) {\n    if (typeof event.data === \"string\") {\n      try {\n        const data = JSON.parse(event.data);\n        this.handleTextMessage(data);\n      } catch (error) {\n        this.emit(AgentEvents.Error, {\n          event,\n          data: event.data,\n          message: \"Unable to parse `data` as JSON.\",\n          error\n        });\n      }\n    } else if (event.data instanceof Blob) {\n      event.data.arrayBuffer().then(buffer => {\n        this.handleBinaryMessage(Buffer.from(buffer));\n      });\n    } else if (event.data instanceof ArrayBuffer) {\n      this.handleBinaryMessage(Buffer.from(event.data));\n    } else if (Buffer.isBuffer(event.data)) {\n      this.handleBinaryMessage(event.data);\n    } else {\n      console.log(\"Received unknown data type\", event.data);\n      this.emit(AgentEvents.Error, {\n        event,\n        message: \"Received unknown data type.\"\n      });\n    }\n  }\n  /**\n   * Handles binary messages received from the WebSocket connection.\n   * @param data - The binary data.\n   */\n  handleBinaryMessage(data) {\n    this.emit(AgentEvents.Audio, data);\n  }\n  /**\n   * Handles text messages received from the WebSocket connection.\n   * @param data - The parsed JSON data.\n   */\n  handleTextMessage(data) {\n    if (data.type in AgentEvents) {\n      this.emit(data.type, data);\n    } else {\n      this.emit(AgentEvents.Unhandled, data);\n    }\n  }\n  /**\n   * To be called with your model configuration BEFORE sending\n   * any audio data.\n   * @param options - The SettingsConfiguration object.\n   */\n  configure(options) {\n    var _a, _b, _c;\n    if (!((_a = options.agent.listen) === null || _a === void 0 ? void 0 : _a.provider.model.startsWith(\"nova-3\")) && ((_c = (_b = options.agent.listen) === null || _b === void 0 ? void 0 : _b.provider.keyterms) === null || _c === void 0 ? void 0 : _c.length)) {\n      throw new DeepgramError(\"Keyterms are only supported with the Nova 3 models.\");\n    }\n    const string = JSON.stringify(Object.assign({\n      type: \"Settings\"\n    }, options));\n    this.send(string);\n  }\n  /**\n   * Provide new system prompt to the LLM.\n   * @param prompt - The system prompt to provide.\n   */\n  updatePrompt(prompt) {\n    this.send(JSON.stringify({\n      type: \"UpdatePrompt\",\n      prompt\n    }));\n  }\n  /**\n   * Change the speak model.\n   * @param model - The new model to use.\n   */\n  updateSpeak(speakConfig) {\n    this.send(JSON.stringify({\n      type: \"UpdateSpeak\",\n      speak: speakConfig\n    }));\n  }\n  /**\n   * Immediately trigger an agent message. If this message\n   * is sent while the user is speaking, or while the server is in the\n   * middle of sending audio, then the request will be ignored and an InjectionRefused\n   * event will be emitted.\n   * @example \"Hold on while I look that up for you.\"\n   * @example \"Are you still on the line?\"\n   * @param content - The message to speak.\n   */\n  injectAgentMessage(content) {\n    this.send(JSON.stringify({\n      type: \"InjectAgentMessage\",\n      content\n    }));\n  }\n  /**\n   * Respond to a function call request.\n   * @param response  - The response to the function call request.\n   */\n  functionCallResponse(response) {\n    this.send(JSON.stringify(Object.assign({\n      type: \"FunctionCallResponse\"\n    }, response)));\n  }\n  /**\n   * Send a keepalive to avoid closing the websocket while you\n   * are not transmitting audio. This should be sent at least\n   * every 8 seconds.\n   */\n  keepAlive() {\n    this.send(JSON.stringify({\n      type: \"KeepAlive\"\n    }));\n  }\n}","map":{"version":3,"names":["DEFAULT_AGENT_URL","AgentEvents","DeepgramError","AbstractLiveClient","AgentLiveClient","constructor","options","endpoint","namespace","baseUrl","_d","_c","_b","_a","agent","websocket","url","connect","setupConnection","conn","onopen","emit","Open","onclose","event","Close","onerror","Error","onmessage","handleMessage","data","JSON","parse","handleTextMessage","error","message","Blob","arrayBuffer","then","buffer","handleBinaryMessage","Buffer","from","ArrayBuffer","isBuffer","console","log","Audio","type","Unhandled","configure","listen","provider","model","startsWith","keyterms","length","string","stringify","Object","assign","send","updatePrompt","prompt","updateSpeak","speakConfig","speak","injectAgentMessage","content","functionCallResponse","response","keepAlive"],"sources":["/Users/armeshpereira/Documents/LastAttempt/reactapp/node_modules/@deepgram/sdk/src/packages/AgentLiveClient.ts"],"sourcesContent":["import { DEFAULT_AGENT_URL } from \"../lib/constants\";\nimport { AgentEvents } from \"../lib/enums/AgentEvents\";\nimport { DeepgramError } from \"../lib/errors\";\nimport type { AgentLiveSchema, DeepgramClientOptions, FunctionCallResponse } from \"../lib/types\";\nimport { AbstractLiveClient } from \"./AbstractLiveClient\";\n\nexport class AgentLiveClient extends AbstractLiveClient {\n  public namespace: string = \"agent\";\n\n  constructor(options: DeepgramClientOptions, endpoint: string = \"/:version/agent/converse\") {\n    super(options);\n    this.baseUrl = options.agent?.websocket?.options?.url ?? DEFAULT_AGENT_URL;\n\n    this.connect({}, endpoint);\n  }\n\n  /**\n   * Sets up the connection event handlers.\n   * This method is responsible for handling the various events that can occur on the WebSocket connection, such as opening, closing, and receiving messages.\n   * - When the connection is opened, it emits the `AgentEvents.Open` event.\n   * - When the connection is closed, it emits the `AgentEvents.Close` event.\n   * - When an error occurs on the connection, it emits the `AgentEvents.Error` event.\n   * - When a message is received, it parses the message and emits the appropriate event based on the message type.\n   */\n  public setupConnection(): void {\n    if (this.conn) {\n      this.conn.onopen = () => {\n        this.emit(AgentEvents.Open, this);\n      };\n\n      this.conn.onclose = (event: any) => {\n        this.emit(AgentEvents.Close, event);\n      };\n\n      this.conn.onerror = (event: ErrorEvent) => {\n        this.emit(AgentEvents.Error, event);\n      };\n\n      this.conn.onmessage = (event: MessageEvent) => {\n        this.handleMessage(event);\n      };\n    }\n  }\n\n  /**\n   * Handles incoming messages from the WebSocket connection.\n   * @param event - The MessageEvent object representing the received message.\n   */\n  protected handleMessage(event: MessageEvent): void {\n    if (typeof event.data === \"string\") {\n      try {\n        const data = JSON.parse(event.data);\n        this.handleTextMessage(data);\n      } catch (error) {\n        this.emit(AgentEvents.Error, {\n          event,\n          data: event.data,\n          message: \"Unable to parse `data` as JSON.\",\n          error,\n        });\n      }\n    } else if (event.data instanceof Blob) {\n      event.data.arrayBuffer().then((buffer) => {\n        this.handleBinaryMessage(Buffer.from(buffer));\n      });\n    } else if (event.data instanceof ArrayBuffer) {\n      this.handleBinaryMessage(Buffer.from(event.data));\n    } else if (Buffer.isBuffer(event.data)) {\n      this.handleBinaryMessage(event.data);\n    } else {\n      console.log(\"Received unknown data type\", event.data);\n      this.emit(AgentEvents.Error, {\n        event,\n        message: \"Received unknown data type.\",\n      });\n    }\n  }\n\n  /**\n   * Handles binary messages received from the WebSocket connection.\n   * @param data - The binary data.\n   */\n  protected handleBinaryMessage(data: Buffer): void {\n    this.emit(AgentEvents.Audio, data);\n  }\n\n  /**\n   * Handles text messages received from the WebSocket connection.\n   * @param data - The parsed JSON data.\n   */\n  protected handleTextMessage(data: any): void {\n    if (data.type in AgentEvents) {\n      this.emit(data.type, data);\n    } else {\n      this.emit(AgentEvents.Unhandled, data);\n    }\n  }\n\n  /**\n   * To be called with your model configuration BEFORE sending\n   * any audio data.\n   * @param options - The SettingsConfiguration object.\n   */\n  public configure(options: AgentLiveSchema): void {\n    if (\n      !options.agent.listen?.provider.model.startsWith(\"nova-3\") &&\n      options.agent.listen?.provider.keyterms?.length\n    ) {\n      throw new DeepgramError(\"Keyterms are only supported with the Nova 3 models.\");\n    }\n    const string = JSON.stringify({\n      type: \"Settings\",\n      ...options,\n    });\n    this.send(string);\n  }\n\n  /**\n   * Provide new system prompt to the LLM.\n   * @param prompt - The system prompt to provide.\n   */\n  public updatePrompt(prompt: string): void {\n    this.send(JSON.stringify({ type: \"UpdatePrompt\", prompt }));\n  }\n\n  /**\n   * Change the speak model.\n   * @param model - The new model to use.\n   */\n  public updateSpeak(speakConfig: Exclude<AgentLiveSchema[\"agent\"][\"speak\"], undefined>): void {\n    this.send(JSON.stringify({ type: \"UpdateSpeak\", speak: speakConfig }));\n  }\n\n  /**\n   * Immediately trigger an agent message. If this message\n   * is sent while the user is speaking, or while the server is in the\n   * middle of sending audio, then the request will be ignored and an InjectionRefused\n   * event will be emitted.\n   * @example \"Hold on while I look that up for you.\"\n   * @example \"Are you still on the line?\"\n   * @param content - The message to speak.\n   */\n  public injectAgentMessage(content: string): void {\n    this.send(JSON.stringify({ type: \"InjectAgentMessage\", content }));\n  }\n\n  /**\n   * Respond to a function call request.\n   * @param response  - The response to the function call request.\n   */\n  public functionCallResponse(response: FunctionCallResponse): void {\n    this.send(JSON.stringify({ type: \"FunctionCallResponse\", ...response }));\n  }\n\n  /**\n   * Send a keepalive to avoid closing the websocket while you\n   * are not transmitting audio. This should be sent at least\n   * every 8 seconds.\n   */\n  public keepAlive(): void {\n    this.send(JSON.stringify({ type: \"KeepAlive\" }));\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}